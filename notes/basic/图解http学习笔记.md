# 图解HTTP学习笔记

## 1 TCP/IP协议族

### 1.1 TCP/IP的分层管理

- 应用层：应用层决定了向用户提供应用服务时通信的活动。TCP/IP协议族内预存了各类通用的应用服务。如：FTP、DNS、HTTP等。
- 传输层：传输层对上层应用层，提供处于网络链接中的两台计算机之间的数据传输。  

  传输层中的两种不同的协议：
  - TCP：传输控制协议
  - UDP：用户数据报协议
- 网络层:网络层用来处理在网络上流动的数据包，该层规定了通过怎样的传输路径将数据包传送到对方的计算机。
- 数据链路层:用来处理连接网络的硬件部分。包括操作系统、硬件设备驱动、网卡、光钎等硬件。

### 1.2 TCP/IP通信传输流

利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层上走。  

发送端：应用层→传输层→网络层→链路层  
接收端：链路层→网络层→传输层→应用层  

发送端在层与层之间传输时，每经过一层时必定会被打上一个该层所属的首部信息。接收端在层与层传输数据时，每经过一层时会把对应的首部信息消去。这种把数据信息包装起来的做法称为封装。

### 1.3 IP、TCP和DNS

#### 1.3.1 IP协议

IP协议位于网络层，作用是把各种数据包传送给对方。IP协议要想将数据包准确的传输到对方的电脑，需要的两个重要的条件就是IP地址和MAC地址。并使用ARP协议（根据IP地址获取物理地址的一个TCP/IP协议）凭借MAC地址进行通信。

IP地址和MAC地址：

- IP地址：指明了节点被分配到的地址
- MAC地址：网卡的固定物理地址，大部分的时候不会改变（可通过工具来修改）

在到达通信目标的中转过程中，计算机和路由器等网络设备只能熟悉很粗略的传输路线，这种机制叫做路由选择。

### 1.4 确保可靠性的TCP协议

TCP协议位于传输层，提供可靠的字节流服务。字节流服务是指，为了方便传输，将大块数据分割以报分段为单位的数据进行管理。TCP协议使用三次握手策略保证数据准确无误的到达目标处。 

TCP三次握手策略：  

为了准确无误的将数据送到对方，TCP协议在传输数据后会向对方确认是否送达。握手的过程中使用了TCP的标志——SYN（同步标志）和ACK（确认标志）。 

三次握手过程（来自维基百科）：  

TCP用三路握手（或称三次握手，three-way handshake）过程创建一个连接。在连接创建过程中，很多参数要被初始化，例如序号被初始化以保证按序传输和连接的强壮性。  
一对终端同时初始化一个它们之间的连接是可能的。但通常是由一端打开一个套接字（socket）然后监听来自另一方的连接，这就是通常所指的被动打开（passive open）。服务器端被被动打开以后，用户端就能开始创建主动打开（active open）。  

1. 客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数A。
2. 服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身又有一个随机产生的序号B。
3. 最后，客户端再发送一个ACK。当服务端收到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包的序号被设定为收到的确认号A+1，而响应号则为B+1。  

如果服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会断开这个连接。使用三个TCP参数来调整行为：tcp_synack_retries 减少重试次数；tcp_max_syn_backlog，增大SYN连接数；tcp_abort_on_overflow决定超出能力时的行为。

### 1.5 DNS域名解析服务

和HTTP一样，DNS服务也处于应用层。它提供域名到IP地址间的解析服务。由于IP不方便用户记忆。所以用户通常使用域名或者主机名来访问对方的计算机。DNS协议存在的目的就是通过域名查找对方计算机的IP地址，或逆向从IP地址反查域名服务。

DNS系统中，常见的资源记录类型有（来自维基百科）：

- 主机记录（A记录）：RFC 1035定义，A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。
- 别名记录（CNAME记录）: RFC 1035定义，CNAME记录用于将某个别名指向到某个A记录上，这样就不需要再为某个新名字另外创建一条新的A记录。
- IPv6主机记录（AAAA记录）: RFC 3596定义，与A记录对应，用于将特定的主机名映射到一个主机的IPv6地址。
- 服务位置记录（SRV记录）: RFC 2782定义，用于定义提供特定服务的服务器的位置，如主机（hostname），端口（port number）等。
- NAPTR记录：RFC 3403定义，它提供了正则表达式方式去映射一个域名。NAPTR记录非常著名的一个应用是用于ENUM查询。

### 1.6 一个完整的HTTP通信中，IP、TCP、DNS的作用

当我们打开一个网站，如 http://www.github.com ：

- DNS服务的职责：客户端通过DNS解析服务器（或本地DNS缓存），解析出github对应的IP地址。
- HTTP协议的职责：发送方，生成对目标web服务器的http请求报文。接收方：对web服务器请求的内容进行处理。
- TCP协议的职责：在发送方，为了方便通信，将HTTP请求报文分给成报文段，并传送给对方。在接收方，按照序号，将对方传送过来的报文段进行重组。
- IP协议的职责：搜索对方的地址，一边中专一边传送。

### 1.7 URI、URL、URN

> 内容来自维基百科

- URI：统一资源标识符  
  统一资源标识符（英语：Uniform Resource Identifier，或URI）是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。URI的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径。用于在特定的名字空间资源的标识，以补充网址。

- URL：统一资源定位符  
  统一资源定位符（或称统一资源定位器/定位地址、URL地址等[1]，英语：Uniform Resource Locator，常缩写为URL），有时也被俗称为网页地址（网址）。如同在网络上的门牌，是因特网上标准的资源的地址（Address）

- URN：统一资源名称  
  统一资源名称（英语：Uniform Resource Name，或URN）是统一资源标识（URI）的历史名字

#### 1.7.1 URI与URL和URN的关系

URL(定位符)和URN(名称)方案属于URI的子类，URI可以为URL或URN两者之一或同时是URI和URN。技术上讲，URL和URN属于资源ID；但是，人们往往无法将某种方案归类于两者中的某一个：所有的URI都可被作为名称看待，而某些方案同时体现了两者中的不同部分。

URI可被视为定位符（URL），名称（URN）或两者兼备。统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。

#### 1.7.2 URI格式

URI文法由URI协议名（例如“http”，“ftp”，“mailto”或“file”），一个冒号，和协议对应的内容所构成。特定的协议定义了协议内容的语法和语义，而所有的协议都必须遵循一定的URI文法通用规则，亦即为某些专门目的保留部分特殊字符。URI文法同时也就各种原因对协议内容加以其他的限制，例如，保证各种分层协议之间的协同性。百分号编码也为URI提供附加信息。

通用URI的格式如下：
```
 scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
```

## 2 HTTP协议

超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。

### 2.1 HTTP方法

| 方法名称 | 说明 | 支持的HTTP协议版本 |
| ------ | ------ | ------ |
| GET | 用来请求已被URI识别的资源 | 1.0、1.1 |
| POST | 传输实体的主体 | 1.0、1.1 |
| PUT | 传输文件 | 1.0、1.1 |
| HEAD | 获得报文首部。HEAD方法和GET方法类似，只是不返回报文的主体部分。用于确认URI的有效性和资源更新的时间等。 | 1.0、1.1 |
| DELETE | 删除文件，与PUT方法相反 | 1.0、1.1 |
| OPTIONS | 用来查询针对请求URI指定的资源支持的方法 | 1.1 |
| TRACE | 让WEB服务器端将之前的请求通信环回给客户端的方法。不常用，并且容易引发XST攻击。 | 1.1 |
| CONNECT | 要求使用隧道协议链接代理，与服务器通信时建立隧道，实现用隧道协议进行TCP通信。 | 1.1 |
| LINK | 建立和资源之间的联系 | 1.0 |
| UNLINK | 断开连接关系 | 1.0 |

### 2.2 持久连接

> 内容来自维基百科

HTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。

在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。然而， Apache 2.0 httpd 的默认连接过期时间是仅仅15秒，对于 Apache 2.2 只有5秒。短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。

优点：

- 较少的CPU和内存的使用（由于同时打开的连接的减少了）
- 允许请求和应答的HTTP管线化
- 降低拥塞控制 （TCP连接减少了）
- 减少了后续请求的延迟（无需再进行握手）
- 报告错误无需关闭TCP连接

缺点：

对于现在的广泛普及的宽带连接来说，Keep-Alive也许并不像以前一样有用。web服务器会保持连接若干秒(Apache中默认15秒)，这与提高的性能相比也许会影响性能。

对于单个文件被不断请求的服务(例如图片存放网站)，Keep-Alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。


### 2.3 管线化
HTTP管线化是将多个HTTP请求整批提交的技术，而在发送过程中不需先等待服务端的回应。持久连接使得多数请求以管线化的方式发送成为可能，这样就能同时并行发送多个请求，而不需要一个接一个的等待响应。

### 2.4 使用Cookie进行状态管理

HTTP时无状态协议，它不对之前发生过的请求状态进行管理，无法根据之前的状态进行本次的请求处理。为了解决这个问题，引入了Cookie技术进行状态管理。

Cookie的使用原理：

- Cookie通过在请求和响应的报文中写入Cookie信息来控制客户端状态。
- Cookie会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部段信息，通知客户端保存Cookie。当下次客户端再发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务端发现客户端发送的Cookie后，会去检查其属于哪个客户端，然后对比服务器上的记录，得到之前的状态信息。

Cookie的缺陷：

- Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。
- 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用- HTTPS。
- Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。

### 2.5 HTTP版本

> 内容来自维基百科

超文本传输协议已经演化出了很多版本，它们中的大部分都是向下兼容的。在 RFC 2145 中描述了HTTP版本号的用法。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。

- HTTP/0.9  
  已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。

- HTTP/1.0  
  这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。

- HTTP/1.1  
  持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。

- HTTP/2  
  当前版本，于2015年5月作为互联网标准正式发布。

HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：
  * 缓存处理
  * 带宽优化及网络连接的使用
  * 错误通知的管理
  * 消息在网络中的发送
  * 互联网地址的维护
  * 安全性及完整性

HTTP/2与HTTP/1.1比较：  
HTTP/2 相比 HTTP/1.1 的修改并不会破坏现有程序的工作，但是新的程序可以借由新特性得到更好的速度。

HTTP/2 保留了 HTTP/1.1 的大部分语义，例如请求方法、状态码乃至URI和绝大多数HTTP头部字段一致。而 HTTP/2 采用了新的方法来编码、传输客户端——服务器间的数据。  

## 3. HTTP报文

### 3.1 认识HTTP报文

什么是HTTP报文？  
用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的叫做响应报文。

### 3.2 HTTP报文结构

请求/响应报文由以下内容组成：

| 结构 | 说明 |
| ----- | ----- |
| 报文首部 | 服务器端或客户端处理的请求或响应的内容以及属性 |
| 空行（CR+LF）| CR（回车符:16进制的0x0d）和LF（换行符：16进制0x0a）|
| 报文主体 | 应被发送的数据 |

报文首部的组成：
- 请求行，例如：GET /logo.gif HTTP/1.1或状态码行，例如：HTTP/1.1 200 OK，

- 首部字段：包含表示请求的各种条件和属性的各类首部。 一般有4种首部：通用首部、请求首部、响应首部、实体首部

- 其他： 可能包含HTTP的RFC里未定义的首部（Cookie等）。

### 3.3 HTTP编码提升传输速率

在HTTP的传输过程中，可以通过编码提升传输速率。通过在传输时编码，能有效的处理大量的访问请求。HTTP压缩是一种内置到网页服务器和网页客户端中以改进传输速度和带宽利用率的方式。

#### 3.3.1 报文主体和实体主体的差异：

- 报文：是HTTP通信中的基本单位，由8位字节流组成，通过HTTP通信传输。

- 实体：作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。

- 差异：通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体内容发生变化，才导致它和报文主体产生差异。

#### 3.3.2 压缩传输内容的编码

压缩的实现：  

在HTTP中有两种不同的方式可以完成压缩。在较低层级，Transfer-Encoding头可以指示HTTP消息的有效载荷被压缩。在较高层级，Content-Encoding头可以指示一个被转码、缓存或引用的资源已压缩。使用Content-Encoding的压缩比Transfer-Encoding有更广泛的支持，并且某些浏览器不宣告Transfer-Encoding压缩以避免触发服务器的缺陷。

压缩方案的协商：

> 内容来自维基百科

在大多数情况中（不包括SDCH），协商使用两个步骤完成，这描述在RFC 2616：

1. 网页客户端在HTTP请求的头部通告其支持的压缩方案为一个标记列表（tokens）。对于Content-Encoding，这个列表称作Accept-Encoding；对于Transfer-Encoding，该字段被称为TE。

```
GET /encrypted-area HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip, deflate

```

2. 如果服务器支持一种或多种压缩方案，输出的数据可能用一种或多种双方支持的方法压缩。如果是这种情况，服务器将在HTTP响应中添加一个Content-Encoding或Transfer-Encoding字段表明使用的方案，用逗号分隔。

```
HTTP/1.1 200 OK
Date: Tue, 27 Feb 2018 06:03:16 GMT
Server: Apache/1.3.3.7 (Unix)  (Red-Hat/Linux)
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
Accept-Ranges: bytes
Content-Length: 438
Connection: close
Content-Type: text/html; charset=UTF-8
Content-Encoding: gzip
```

常见的几种内容编码(Content-Encoding标记)：

- gzip GNU zip格式（定义于RFC 1952）。此方法截至2011年3月，是应用程序支持最广泛的方法。
- compress （UNIX系统的标准压缩）UNIX的“compress”程序的方法（历史性，不推荐大多数应用使用，应该使用gzip或deflate）
- deflate（zlib）基于deflate算法（定义于RFC 1951）的压缩，使用zlib数据格式（RFC 1950）封装
- identity（不进行编码）这是内容编码的默认值。
- br  Brotli，一种新的开源压缩算法，专为HTTP内容的编码而设计，已在Mozilla Firefox 44中实现，并且Chromium正准备实施

#### 3.4 发送多种数据的多部分对象集合

发送的一份报文主体内可含有多类型实体。通常在图片或者文本上传时使用。在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type。

多部分对象集合包含的对象：

- multipart/form-data : 在web表单文件上传时使用。

- multipart/byteranges ：状态码206响应报文包含了多个范围的内容使用。

#### 3.5 获取部分内容的范围请求

执行范围请求时，会用到首部字段Range来制定资源的byte范围。针对范围请求，响应会返回状态码206的响应报文。并且会在首部字段Content-Type表明multipart/byteranges后返回响应报文。若服务端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。

byte范围的指定形式如下：

- Range:bytes=5001-10000  获取5001-10000字节

- Range:bytes=5001-   获取5001后全部的

- Range:bytes=-5001,6000-7000   从一开始到5001字节和6000-7000字节的多重范围

#### 内容协商返回最合适的内容

内容协商机制是指客户端和服务端就响应的资源进行交涉，然后提供给客户端最为合适的资源。

内容协商判断首部字段:

- Accept

- Accept-Charset

- Accept-Encoding

- Accept-Language

- Content-Language

内容协商技术:

- 服务器驱动协商：由服务器进行内容协商，以请求首部字段为参考，在服务器自动处理。

- 客户端驱动协商：用户在浏览器页面中手动选择。

- 透明协商：是服务器和客户端驱动的结合体，是有服务器端和客户端各自进行内容协商的一种方法。
