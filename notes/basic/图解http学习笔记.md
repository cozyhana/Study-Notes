# 图解htpp学习笔记

## 1 TCP/IP协议族

### 1.1 TCP/IP的分层管理

- 应用层：应用层决定了向用户提供应用服务时通信的活动。TCP/IP协议族内预存了各类通用的应用服务。如：FTP、DNS、HTTP等。
- 传输层：传输层对上层应用层，提供处于网络链接中的两台计算机之间的数据传输。  

  传输层中的两种不同的协议：
  - TCP：传输控制协议
  - UDP：用户数据报协议
- 网络层:网络层用来处理在网络上流动的数据包，该层规定了通过怎样的传输路径将数据包传送到对方的计算机。
- 数据链路层:用来处理连接网络的硬件部分。包括操作系统、硬件设备驱动、网卡、光钎等硬件。

### 1.2 TCP/IP通信传输流

利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层上走。  

发送端：应用层→传输层→网络层→链路层  
接收端：链路层→网络层→传输层→应用层  

发送端在层与层之间传输时，每经过一层时必定会被打上一个该层所属的首部信息。接收端在层与层传输数据时，每经过一层时会把对应的首部信息消去。这种把数据信息包装起来的做法称为封装。

### 1.3 IP、TCP和DNS

#### 1.3.1 IP协议

IP协议位于网络层，作用是把各种数据包传送给对方。IP协议要想将数据包准确的传输到对方的电脑，需要的两个重要的条件就是IP地址和MAC地址。并使用ARP协议（根据IP地址获取物理地址的一个TCP/IP协议）凭借MAC地址进行通信。

IP地址和MAC地址：

- IP地址：指明了节点被分配到的地址
- MAC地址：网卡的固定物理地址，大部分的时候不会改变（可通过工具来修改）

在到达通信目标的中转过程中，计算机和路由器等网络设备只能熟悉很粗略的传输路线，这种机制叫做路由选择。

### 1.4 确保可靠性的TCP协议

TCP协议位于传输层，提供可靠的字节流服务。字节流服务是指，为了方便传输，将大块数据分割以报分段为单位的数据进行管理。TCP协议使用三次握手策略保证数据准确无误的到达目标处。 

TCP三次握手策略：  

为了准确无误的将数据送到对方，TCP协议在传输数据后会向对方确认是否送达。握手的过程中使用了TCP的标志——SYN（同步标志）和ACK（确认标志）。 

三次握手过程（来自维基百科）：  

TCP用三路握手（或称三次握手，three-way handshake）过程创建一个连接。在连接创建过程中，很多参数要被初始化，例如序号被初始化以保证按序传输和连接的强壮性。  
一对终端同时初始化一个它们之间的连接是可能的。但通常是由一端打开一个套接字（socket）然后监听来自另一方的连接，这就是通常所指的被动打开（passive open）。服务器端被被动打开以后，用户端就能开始创建主动打开（active open）。  

1. 客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数A。
2. 服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身又有一个随机产生的序号B。
3. 最后，客户端再发送一个ACK。当服务端收到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包的序号被设定为收到的确认号A+1，而响应号则为B+1。  

如果服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会断开这个连接。使用三个TCP参数来调整行为：tcp_synack_retries 减少重试次数；tcp_max_syn_backlog，增大SYN连接数；tcp_abort_on_overflow决定超出能力时的行为。

### 1.5 DNS域名解析服务

和HTTP一样，DNS服务也处于应用层。它提供域名到IP地址间的解析服务。由于IP不方便用户记忆。所以用户通常使用域名或者主机名来访问对方的计算机。DNS协议存在的目的就是通过域名查找对方计算机的IP地址，或逆向从IP地址反查域名服务。

DNS系统中，常见的资源记录类型有（来自维基百科）：

- 主机记录（A记录）：RFC 1035定义，A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。
- 别名记录（CNAME记录）: RFC 1035定义，CNAME记录用于将某个别名指向到某个A记录上，这样就不需要再为某个新名字另外创建一条新的A记录。
- IPv6主机记录（AAAA记录）: RFC 3596定义，与A记录对应，用于将特定的主机名映射到一个主机的IPv6地址。
- 服务位置记录（SRV记录）: RFC 2782定义，用于定义提供特定服务的服务器的位置，如主机（hostname），端口（port number）等。
- NAPTR记录：RFC 3403定义，它提供了正则表达式方式去映射一个域名。NAPTR记录非常著名的一个应用是用于ENUM查询。

### 1.6 一个完整的HTTP通信中，IP、TCP、DNS的作用

当我们打开一个网站，如 http://www.github.com ：

- DNS服务的职责：客户端通过DNS解析服务器（或本地DNS缓存），解析出github对应的IP地址。
- HTTP协议的职责：发送方，生成对目标web服务器的http请求报文。接收方：对web服务器请求的内容进行处理。
- TCP协议的职责：在发送方，为了方便通信，将HTTP请求报文分给成报文段，并传送给对方。在接收方，按照序号，将对方传送过来的报文段进行重组。
- IP协议的职责：搜索对方的地址，一边中专一边传送。

### 1.7 URI、URL、URN

> 内容来自维基百科

- URI：统一资源标识符  
  统一资源标识符（英语：Uniform Resource Identifier，或URI）是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。URI的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径。用于在特定的名字空间资源的标识，以补充网址。

- URL：统一资源定位符  
  统一资源定位符（或称统一资源定位器/定位地址、URL地址等[1]，英语：Uniform Resource Locator，常缩写为URL），有时也被俗称为网页地址（网址）。如同在网络上的门牌，是因特网上标准的资源的地址（Address）

- URN：统一资源名称  
  统一资源名称（英语：Uniform Resource Name，或URN）是统一资源标识（URI）的历史名字

#### 1.7.1 URI与URL和URN的关系

URL(定位符)和URN(名称)方案属于URI的子类，URI可以为URL或URN两者之一或同时是URI和URN。技术上讲，URL和URN属于资源ID；但是，人们往往无法将某种方案归类于两者中的某一个：所有的URI都可被作为名称看待，而某些方案同时体现了两者中的不同部分。

URI可被视为定位符（URL），名称（URN）或两者兼备。统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。

#### 1.7.2 URI格式

URI文法由URI协议名（例如“http”，“ftp”，“mailto”或“file”），一个冒号，和协议对应的内容所构成。特定的协议定义了协议内容的语法和语义，而所有的协议都必须遵循一定的URI文法通用规则，亦即为某些专门目的保留部分特殊字符。URI文法同时也就各种原因对协议内容加以其他的限制，例如，保证各种分层协议之间的协同性。百分号编码也为URI提供附加信息。

通用URI的格式如下：
```
 scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
```

## 2 HTTP协议

超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。

### 2.1 HTTP方法

| 方法名称 | 说明 | 支持的HTTP协议版本 |
| ------ | ------ | ------ |
| GET | 用来请求已被URI识别的资源 | 1.0、1.1 |
| POST | 传输实体的主体 | 1.0、1.1 |
| PUT | 传输文件 | 1.0、1.1 |
| HEAD | 获得报文首部。HEAD方法和GET方法类似，只是不返回报文的主体部分。用于确认URI的有效性和资源更新的时间等。 | 1.0、1.1 |
| DELETE | 删除文件，与PUT方法相反 | 1.0、1.1 |
| OPTIONS | 用来查询针对请求URI指定的资源支持的方法 | 1.1 |
| TRACE | 让WEB服务器端将之前的请求通信环回给客户端的方法。不常用，并且容易引发XST攻击。 | 1.1 |
| CONNECT | 要求使用隧道协议链接代理，与服务器通信时建立隧道，实现用隧道协议进行TCP通信。 | 1.1 |
| LINK | 建立和资源之间的联系 | 1.0 |
| UNLINK | 断开连接关系 | 1.0 |

### 2.2 持久连接

> 内容来自维基百科

HTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。

在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。然而， Apache 2.0 httpd 的默认连接过期时间是仅仅15秒，对于 Apache 2.2 只有5秒。短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。

优点：

- 较少的CPU和内存的使用（由于同时打开的连接的减少了）
- 允许请求和应答的HTTP管线化
- 降低拥塞控制 （TCP连接减少了）
- 减少了后续请求的延迟（无需再进行握手）
- 报告错误无需关闭TCP连接

缺点：

对于现在的广泛普及的宽带连接来说，Keep-Alive也许并不像以前一样有用。web服务器会保持连接若干秒(Apache中默认15秒)，这与提高的性能相比也许会影响性能。

对于单个文件被不断请求的服务(例如图片存放网站)，Keep-Alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。


### 2.3 管线化
HTTP管线化是将多个HTTP请求整批提交的技术，而在发送过程中不需先等待服务端的回应。持久连接使得多数请求以管线化的方式发送成为可能，这样就能同时并行发送多个请求，而不需要一个接一个的等待响应。

### 2.4 使用Cookie进行状态管理

HTTP时无状态协议，它不对之前发生过的请求状态进行管理，无法根据之前的状态进行本次的请求处理。为了解决这个问题，引入了Cookie技术进行状态管理。

Cookie的使用原理：

- Cookie通过在请求和响应的报文中写入Cookie信息来控制客户端状态。
- Cookie会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部段信息，通知客户端保存Cookie。当下次客户端再发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务端发现客户端发送的Cookie后，会去检查其属于哪个客户端，然后对比服务器上的记录，得到之前的状态信息。

Cookie的缺陷：

- Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。
- 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用- HTTPS。
- Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。

### 2.5 HTTP版本

> 内容来自维基百科

超文本传输协议已经演化出了很多版本，它们中的大部分都是向下兼容的。在 RFC 2145 中描述了HTTP版本号的用法。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。

- HTTP/0.9  
  已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。

- HTTP/1.0  
  这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。

- HTTP/1.1  
  持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。

- HTTP/2  
  当前版本，于2015年5月作为互联网标准正式发布。

HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：
  * 缓存处理
  * 带宽优化及网络连接的使用
  * 错误通知的管理
  * 消息在网络中的发送
  * 互联网地址的维护
  * 安全性及完整性

HTTP/2与HTTP/1.1比较：  
HTTP/2 相比 HTTP/1.1 的修改并不会破坏现有程序的工作，但是新的程序可以借由新特性得到更好的速度。

HTTP/2 保留了 HTTP/1.1 的大部分语义，例如请求方法、状态码乃至URI和绝大多数HTTP头部字段一致。而 HTTP/2 采用了新的方法来编码、传输客户端——服务器间的数据。  

## 3. HTTP报文

### 3.1 认识HTTP报文

什么是HTTP报文？  
用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的叫做响应报文。


